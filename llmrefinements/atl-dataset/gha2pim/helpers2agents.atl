-- helpers2agents.atl
-- @nsURI GHA=/d.fe.up.pt.cicd.gha.metamodel/model/GHA.ecore
-- @nsURI CICD=/d.fe.up.pt.cicd.metamodel/model/CICD.ecore

module helpers2agents;
create OUT : CICD from IN : GHA;

-- Job agent mapping helpers
helper context GHA!Job def : getAgent() : CICD!Agent =
    if self.agent.oclIsUndefined() then
        OclUndefined
    else if not thisModule.checkForLabel(self.agent.labels, 'ubuntu').oclIsUndefined() or not thisModule.checkForLabel(self.agent.labels, 'linux').oclIsUndefined() then
        thisModule.Job2LinuxAgent(self)
    else if not thisModule.checkForLabel(self.agent.labels, 'windows').oclIsUndefined() then 
        thisModule.Job2WindowsAgent(self)
    else if not thisModule.checkForLabel(self.agent.labels, 'macos').oclIsUndefined() then 
        thisModule.Job2MacOSAgent(self)
    else
        thisModule.Job2CustomAgent(self)
    endif
    endif
    endif
    endif;

helper def : checkForLabel(labels : Sequence(GHA!Expression), string : String) : CICD!Expression =
    if labels.oclIsUndefined() or labels->isEmpty() then
        OclUndefined
    else
        if labels->first().oclIsTypeOf(GHA!StringLiteral) then 
            if labels->first().expression2String().startsWith(string) then 
                labels->first()
            else
                thisModule.checkForLabel(labels->excluding(labels->first()), string) 
            endif 
        else 
            thisModule.checkForLabel(labels->excluding(labels->first()), string) 
        endif
    endif;

-- Job agent lazy rules
lazy rule Job2LinuxAgent {
    from
        job : GHA!Job
    to
        agent : CICD!LinuxAgent (
            container <- job.container,
            image <- 
                if not thisModule.checkForLabel(job.agent.labels, 'ubuntu').oclIsUndefined() then
                    thisModule.checkForLabel(job.agent.labels, 'ubuntu')
                else
                    thisModule.checkForLabel(job.agent.labels, 'linux')
                endif
        )
}

lazy rule Job2CustomAgent {
    from
        job : GHA!Job
    to
        agent : CICD!CustomAgent(
            labels <- 
                if not job.agent.oclIsUndefined() then
                    job.agent.labels
                else
                    Sequence{}
                endif
        )
}

lazy rule Job2WindowsAgent {
    from
        job : GHA!Job
    to
        agent : CICD!WindowsAgent (
            image <- thisModule.checkForLabel(job.agent.labels, 'windows')
        )
}

lazy rule Job2MacOSAgent {
    from
        job : GHA!Job
    to
        agent : CICD!MacOSAgent (
            image <- thisModule.checkForLabel(job.agent.labels, 'macos'),
            xcode <- thisModule.getCICDProperty(job.agent.labels, 'XCODE')
        )
}

helper def : getCICDProperty(labels : Sequence(GHA!Expression), name : String) : CICD!Expression =
    if labels.oclIsUndefined() or labels->isEmpty() then
        OclUndefined
    else if labels->first().expression2String().startsWith('%%__CICD__' + name + '#%!!__#%!!') then 
        if labels->first().oclIsTypeOf(GHA!Concat) then
            let concat : GHA!Concat = labels->first()
            in
            if concat.expressions->size() = 2 then
                concat.expressions->last()
            else
                thisModule.CreateConcat(concat.expressions->excluding(concat.expressions->first()))
            endif
        else if labels->first().oclIsTypeOf(GHA!StringLiteral) then
            thisModule.String2StringLiteral(labels->first().expression2String().split('#%!!__#%!!')->last())
        else
            OclUndefined
        endif
        endif
    else 
        thisModule.getCICDProperty(labels->excluding(labels->first()), name)
    endif
    endif

lazy rule CreateConcat {
    from
        input : Sequence(GHA!Expression)
    to
        output : CICD!Concat (
            expressions <- input
        )
}

lazy rule NegateExpression {
    from
        expression : GHA!Expression
    to
        negatedExpression : CICD!Negation(
            rhs <- expression
        )
}

lazy rule String2StringLiteral {
    from
        string : String
    to
        stringLiteral : CICD!StringLiteral(
            value <- string
        )
}
